{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2020 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isFloat32ndarrayLike from '@stdlib/assert-is-float32ndarray-like';\nimport { isPrimitive as isNegativeInteger } from '@stdlib/assert-is-negative-integer';\nimport min from '@stdlib/math-base-special-fast-min';\nimport without from '@stdlib/array-base-without';\nimport numel from '@stdlib/ndarray-base-numel';\nimport normalizeIndex from '@stdlib/ndarray-base-normalize-index';\nimport maybeBroadcastArrays from '@stdlib/ndarray-base-maybe-broadcast-arrays';\nimport ndarraylike2ndarray from '@stdlib/ndarray-base-ndarraylike2ndarray';\nimport nditerStacks from '@stdlib/ndarray-iter-stacks';\nimport empty from '@stdlib/ndarray-empty';\nimport { ndarray as base } from '@stdlib/blas-base-sdot';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// MAIN //\n\n/**\n* Computes the dot product of two single-precision floating-point vectors.\n*\n* @param {ndarrayLike} x - first input array\n* @param {ndarrayLike} y - second input array\n* @param {NegativeInteger} [dim=-1] - dimension for which to compute the dot product\n* @throws {TypeError} first argument must be a ndarray containing single-precision floating-point numbers\n* @throws {TypeError} first argument must have at least one dimension\n* @throws {TypeError} second argument must be a ndarray containing single-precision floating-point numbers\n* @throws {TypeError} second argument must have at least one dimension\n* @throws {TypeError} third argument must be a negative integer\n* @throws {Error} input arrays must be broadcast compatible\n* @throws {RangeError} the size of the contracted dimension must be the same for both input arrays\n* @throws {RangeError} third argument is out-of-bounds\n* @returns {ndarray} ndarray containing the dot product\n*\n* @example\n* import Float32Array from '@stdlib/array-float32';\n* import array from '@stdlib/ndarray-array';\n*\n* var x = array( new Float32Array( [ 4.0, 2.0, -3.0, 5.0, -1.0 ] ) );\n* var y = array( new Float32Array( [ 2.0, 6.0, -1.0, -4.0, 8.0 ] ) );\n*\n* var z = sdot( x, y );\n* // returns <ndarray>\n*\n* var v = z.get();\n* // returns -5.0\n*/\nfunction sdot( x, y ) {\n\tvar dim;\n\tvar xsh;\n\tvar ysh;\n\tvar osh;\n\tvar xit;\n\tvar yit;\n\tvar out;\n\tvar tmp;\n\tvar xc;\n\tvar yc;\n\tvar vx;\n\tvar vy;\n\tvar dm;\n\tvar S;\n\tvar v;\n\tvar i;\n\n\tif ( !isFloat32ndarrayLike( x ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be an ndarray containing single-precision floating-point numbers. Value: `%s`.', x ) );\n\t}\n\tif ( !isFloat32ndarrayLike( y ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be an ndarray containing single-precision floating-point numbers. Value: `%s`.', y ) );\n\t}\n\t// Convert the input arrays to \"base\" ndarrays:\n\txc = ndarraylike2ndarray( x );\n\tyc = ndarraylike2ndarray( y );\n\n\t// Resolve the input array shapes:\n\txsh = xc.shape;\n\tysh = yc.shape;\n\n\t// Validate that we've been provided non-zero-dimensional arrays...\n\tif ( xsh.length < 1 ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must have at least one dimension.' ) );\n\t}\n\tif ( ysh.length < 1 ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must have at least one dimension.' ) );\n\t}\n\t// Validate that the dimension argument is a negative integer...\n\tif ( arguments.length > 2 ) {\n\t\tdim = arguments[ 2 ];\n\t\tif ( !isNegativeInteger( dim ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Third argument must be a negative integer. Value: `%s`.', dim ) );\n\t\t}\n\t} else {\n\t\tdim = -1;\n\t}\n\t// Validate that a provided dimension index is within bounds **before** broadcasting...\n\tdm = min( xsh.length, ysh.length ) - 1;\n\tdim = normalizeIndex( dim, dm );\n\tif ( dim === -1 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Third argument must be a value on the interval: [%d,%d]. Value: `%d`.', -dm, -1, arguments[ 2 ] ) );\n\t}\n\t// Validate that the contracted dimension size is the same for both input arrays...\n\tS = xsh[ dim ];\n\tif ( ysh[ dim ] !== S ) {\n\t\tthrow new RangeError( format( 'invalid argument. The size of the contracted dimension must be the same for both input ndarrays. Dim(%s,%d) = %d. Dim(%s,%d) = %d.', 'x', dim, S, 'y', dim, ysh[ dim ] ) );\n\t}\n\t// Broadcast the input arrays to a common shape....\n\ttry {\n\t\ttmp = maybeBroadcastArrays( [ xc, yc ] );\n\t} catch ( err ) { // eslint-disable-line no-unused-vars\n\t\tthrow new Error( format( 'invalid arguments. Input ndarrays must be broadcast compatible. Shape(%s) = (%s). Shape(%s) = (%s).', 'x', xsh.join( ',' ), 'y', ysh.join( ',' ) ) );\n\t}\n\txc = tmp[ 0 ];\n\tyc = tmp[ 1 ];\n\n\t// Resolve the output array shape by excluding the contracted dimension:\n\tosh = without( xc.shape, dim );\n\n\t// Allocate an empty output array:\n\tout = empty( osh, {\n\t\t'dtype': xc.dtype,\n\t\t'order': xc.order\n\t});\n\n\t// If we are only provided one-dimensional input arrays, we can skip iterating over stacks...\n\tif ( osh.length === 0 ) {\n\t\tv = base( S, xc.data, xc.strides[0], xc.offset, yc.data, yc.strides[0], yc.offset ); // eslint-disable-line max-len\n\t\tout.iset( v );\n\t\treturn out;\n\t}\n\t// Create iterators for iterating over stacks of vectors:\n\txit = nditerStacks( xc, [ dim ] );\n\tyit = nditerStacks( yc, [ dim ] );\n\n\t// Compute the dot product for each pair of vectors...\n\tfor ( i = 0; i < numel( osh ); i++ ) {\n\t\tvx = xit.next().value;\n\t\tvy = yit.next().value;\n\t\tv = base( S, vx.data, vx.strides[0], vx.offset, vy.data, vy.strides[0], vy.offset ); // eslint-disable-line max-len\n\t\tout.iset( i, v );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default sdot;\n"],"names":["sdot","x","y","dim","xsh","ysh","osh","xit","yit","out","tmp","xc","yc","vx","vy","dm","S","v","i","isFloat32ndarrayLike","TypeError","format","ndarraylike2ndarray","shape","length","arguments","isNegativeInteger","min","normalizeIndex","RangeError","maybeBroadcastArrays","err","Error","join","without","empty","dtype","order","base","data","strides","offset","iset","nditerStacks","numel","next","value"],"mappings":";;iqCAmEA,SAASA,EAAMC,EAAGC,GACjB,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAEJ,IAAMC,EAAsBlB,GAC3B,MAAM,IAAImB,UAAWC,EAAQ,uHAAwHpB,IAEtJ,IAAMkB,EAAsBjB,GAC3B,MAAM,IAAIkB,UAAWC,EAAQ,wHAAyHnB,IAWvJ,GARAS,EAAKW,EAAqBrB,GAC1BW,EAAKU,EAAqBpB,GAG1BE,EAAMO,EAAGY,MACTlB,EAAMO,EAAGW,MAGJnB,EAAIoB,OAAS,EACjB,MAAM,IAAIJ,UAAWC,EAAQ,uEAE9B,GAAKhB,EAAImB,OAAS,EACjB,MAAM,IAAIJ,UAAWC,EAAQ,wEAG9B,GAAKI,UAAUD,OAAS,GAEvB,IAAME,EADNvB,EAAMsB,UAAW,IAEhB,MAAM,IAAIL,UAAWC,EAAQ,4EAA6ElB,SAG3GA,GAAO,EAKR,GAFAY,EAAKY,EAAKvB,EAAIoB,OAAQnB,EAAImB,QAAW,GAEvB,KADdrB,EAAMyB,EAAgBzB,EAAKY,IAE1B,MAAM,IAAIc,WAAYR,EAAQ,2FAA4FN,GAAK,EAAGU,UAAW,KAI9I,GADAT,EAAIZ,EAAKD,GACJE,EAAKF,KAAUa,EACnB,MAAM,IAAIa,WAAYR,EAAQ,qIAAsI,IAAKlB,EAAKa,EAAG,IAAKb,EAAKE,EAAKF,KAGjM,IACCO,EAAMoB,EAAsB,CAAEnB,EAAIC,GAClC,CAAC,MAAQmB,GACT,MAAM,IAAIC,MAAOX,EAAQ,sGAAuG,IAAKjB,EAAI6B,KAAM,KAAO,IAAK5B,EAAI4B,KAAM,MACrK,CAcD,GAbAtB,EAAKD,EAAK,GACVE,EAAKF,EAAK,GAGVJ,EAAM4B,EAASvB,EAAGY,MAAOpB,GAGzBM,EAAM0B,EAAO7B,EAAK,CACjB8B,MAASzB,EAAGyB,MACZC,MAAS1B,EAAG0B,QAIO,IAAf/B,EAAIkB,OAGR,OAFAP,EAAIqB,EAAMtB,EAAGL,EAAG4B,KAAM5B,EAAG6B,QAAQ,GAAI7B,EAAG8B,OAAQ7B,EAAG2B,KAAM3B,EAAG4B,QAAQ,GAAI5B,EAAG6B,QAC3EhC,EAAIiC,KAAMzB,GACHR,EAOR,IAJAF,EAAMoC,EAAchC,EAAI,CAAER,IAC1BK,EAAMmC,EAAc/B,EAAI,CAAET,IAGpBe,EAAI,EAAGA,EAAI0B,EAAOtC,GAAOY,IAC9BL,EAAKN,EAAIsC,OAAOC,MAChBhC,EAAKN,EAAIqC,OAAOC,MAChB7B,EAAIqB,EAAMtB,EAAGH,EAAG0B,KAAM1B,EAAG2B,QAAQ,GAAI3B,EAAG4B,OAAQ3B,EAAGyB,KAAMzB,EAAG0B,QAAQ,GAAI1B,EAAG2B,QAC3EhC,EAAIiC,KAAMxB,EAAGD,GAEd,OAAOR,CACR"}